% Generated by roxygen2 (4.0.2): do not edit by hand
\name{permu.new}
\alias{permu.new}
\title{permu.new}
\usage{
permu.new(perm, fun, funsave, values = 0, savemax = 1e+05, cores = NULL,
  cluster = NULL)
}
\arguments{
\item{perm}{numeric vector; numbers which should be permuted}

\item{fun}{function; callback function with 1 parameter. See examples for more information.}

\item{funsave}{function; callback function with 2 parameters: \code{x} for current permutations and \code{resultobject} for saving purposes. See examples for more information.}

\item{values}{numeric; Cache for \code{resultobject}}

\item{savemax}{numeric; Cache of results calculated by \code{fun}}

\item{cores}{numeric; Number of preocessors should be used}

\item{cluster}{cluster-variable created by \code{\link{makeCluster}} if more computers should be used.}
}
\value{
list of all return values of \code{funsave}.
}
\description{
INTERNAL. Generates permutations of \code{perm} and calls a callback \code{fun} for every permutation, without preallocating
memory. It uses SNOW-package for parallel computing. This helps, when permutating very large vectors.
}
\examples{
#callback "fun"
perm.callback.FUN.STUMP <- function(x,resultobject){
 resultobject[CONST_SAVE] <-TRUE
 resultobject[CONST_SKIP] <-FALSE

 return(resultobject)
}

#callback "funsave"
perm.callback.FUNSAVE.STUMP <- function(resultlist){
 res <- resultlist[['resultobject']]
 lis <- resultlist[['results']]

 return(list(results=lis, resultobject= res))
}

# Example:
#----------------------------------------------------------------
# EXAMPLE CALLBACK
#----------------------------------------------------------------
# Prunes, if 3 is last number in permutation
# Saves only, if sum() of permutation is the highest found yet.
# IMPORTANT: return has to be a "resultobject", which is provided
# through the parameters.
# Use
# resultobject[CONST_SKIP] <- TRUE/FALSE (prune after this permutation T/F)
# resultobject[CONST_SAVE] <- TRUE/FALSE (return this permutation, save it T/F)
# resultobject[CONST_VAL]  <- NUMERIC (use this to save something for the process)
#-----------------------------------------------------------------
perm.callback <- function(x,resultobject){

 #CALCULATE STUFF HERE;

 #SKIP EXAMPLE
 #Skip this one? skip next permutations if the last number is 3
 resultobject[CONST_SKIP] <- (x[length(x)] == 3)

 #SAVE EXAMPLE
 #Should we save this permutation?
 #Save only, if sum of permutation is bigger than the ones we already saved.
 s <- sum(x)
 if(s > resultobject[CONST_VAL]){
   resultobject[CONST_VAL]  <- s
   resultobject[CONST_SAVE] <-TRUE
 }else{
   resultobject[CONST_SAVE] <-FALSE
 }

 return(resultobject)
}

#----------------------------------------------------------------
# EXAMPLE CALLBACK FOR SAVING
#-----------------------------------------------------------------
# Orders resultlist, saves only "TOP 50"
#
# INPUT: List with 2 items: 'resultobject' and 'results'
# res <- resultlist[['resultobject']]
# lis <- resultlist[['results']]
#
# OUTPUT: (list with item 'results'(resultlist)) and resultobject,
#         to pass on to further calculations
# return(list(results=lis, resultobject= res))
#-----------------------------------------------------------------
perm.callback.save <- function(resultlist){
 res <- resultlist[['resultobject']]
 lis <- resultlist[['results']]

 # ORDER RESULTLIST
 if(length(lis) > 0){

   #For Example "TOP 50": Only save the top 50!
   allvals <- sapply(lis, function(x) x[['values']], simplify = TRUE ) # get all values

   lis <- lis[  order( allvals )  ]                   # order list by values

   if(length(lis) > 50)
     lis <- lis[1:50]                                 # only save Top 50

   res[CONST_VAL] <- max(allvals)
 }

 return(list(results=lis, resultobject= res))
}

#Execution
result <- permu.new(perm=1:10, fun=perm.callback,funsave=perm.callback.save,values=1, cores = 4)
}

